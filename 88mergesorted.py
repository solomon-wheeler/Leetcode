class Solution:
    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        compare_pointer, locaction_in_1, loation_in_2 = m + n - 1, m - 1, n-1
        while compare_pointer >= 0:

            if locaction_in_1 < 0:
                nums1[compare_pointer] = nums2[loation_in_2]
                loation_in_2 -= 1
            elif loation_in_2 < 0:
                nums1[compare_pointer] = nums1[locaction_in_1]
                locaction_in_1 -= 1
            else:
                if nums1[locaction_in_1] > nums2[loation_in_2]:
                    nums1[compare_pointer] = nums1[locaction_in_1]
                    locaction_in_1 -= 1
                else:
                    nums1[compare_pointer] = nums2[loation_in_2]
                    loation_in_2 -= 1
            compare_pointer -= 1
       


          

test_solution = Solution()

## Test cases
import random

def generate_sorted_list(size, start=0, end=100):
    return sorted(random.sample(range(start, end), size))

# Generate two sorted lists
## GENERATED BY AI
m = 5
n = 3
nums1 = generate_sorted_list(m) + [0] * n  # nums1 needs to have space for nums2
nums2 = generate_sorted_list(n)

print("Before merge:")
print("nums1:", nums1)
print("nums2:", nums2)

# Create an instance of Solution and call the merge method
test_solution = Solution()
test_solution.merge(nums1, m, nums2, n)

print("After merge:")
print("nums1:", nums1)

### Pseudo code
# Start at the end of nums 1
# Compare last element of nums 1 with last element of nums 2, if nums 2 is greater add, if not add from num 2. 
# Move highest pointer to the left for nums 1 / nums 2
# Go back one in overall list and compare